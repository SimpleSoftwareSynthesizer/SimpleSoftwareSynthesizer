#include "SynthAudioSource.h"
#include "SyneWaveVoice.h"
#include "SyneWaveSound.h"

SynthAudioSource::SynthAudioSource(MidiKeyboardState& keyboardState_, double* volume_)
        : keyboardState (keyboardState_),
		  volume (volume_)
    {

        // Der Synthesizer erhält 32 Voices --> Poliphonie
        for (int i = 32; --i >= 0;)
        {
			synth.addVoice(new SyneWaveVoice(volume));          
        }
		
        // Hier erhält der Synthesizer seinen Sinussound
        setUsingSineWaveSound();
    }

     void SynthAudioSource::setUsingSineWaveSound()
    {
        synth.clearSounds();
        synth.addSound (new SyneWaveSound());
    }



SynthAudioSource::~SynthAudioSource(void)
{
}

void SynthAudioSource::prepareToPlay (int /*samplesPerBlockExpected*/, double sampleRate)
    {
        midiCollector.reset (sampleRate);

        synth.setCurrentPlaybackSampleRate (sampleRate);
    }

    void SynthAudioSource::releaseResources()
    {
    }

    void SynthAudioSource::getNextAudioBlock (const AudioSourceChannelInfo& bufferToFill)
    {
        // the synth always adds its output to the audio buffer, so we have to clear it
        // first..
        bufferToFill.clearActiveBufferRegion();

        // fill a midi buffer with incoming messages from the midi input.
        MidiBuffer incomingMidi;
        midiCollector.removeNextBlockOfMessages (incomingMidi, bufferToFill.numSamples);

        // pass these messages to the keyboard state so that it can update the component
        // to show on-screen which keys are being pressed on the physical midi keyboard.
        // This call will also add midi messages to the buffer which were generated by
        // the mouse-clicking on the on-screen keyboard.
        keyboardState.processNextMidiBuffer (incomingMidi, 0, bufferToFill.numSamples, true);

        // and now get the synth to process the midi events and generate its output.
        synth.renderNextBlock (*bufferToFill.buffer, incomingMidi, 0, bufferToFill.numSamples);
    }

